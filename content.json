{"meta":{"title":"WY's blog","subtitle":null,"description":null,"author":"WangY","url":"the-valley.github.io","root":"/"},"pages":[],"posts":[{"title":"springboot集成quartz实现定时任务调度","slug":"springboot集成quartz实现定时任务调度","date":"2019-05-05T03:25:40.000Z","updated":"2019-05-05T10:01:43.009Z","comments":true,"path":"2019/05/05/springboot集成quartz实现定时任务调度/","link":"","permalink":"the-valley.github.io/2019/05/05/springboot集成quartz实现定时任务调度/","excerpt":"在工作中需要写一个定时任务，在网上查阅了quartz任务调度框架相关资料，考虑到后期可能会有业务扩展所以决定用quartz来完成，在spirngboot 2以后可以直接通过starter的方式来引入。pom依赖如下： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt; quartz的主要组件 Jobdetail包含具体的任务信息 Trigger任务的触发器 Schedule具体的调度机制 SimpleScheduleBuilder简单任务调度 CronScheduleBuilder基于Crontab规则的任务调度","text":"在工作中需要写一个定时任务，在网上查阅了quartz任务调度框架相关资料，考虑到后期可能会有业务扩展所以决定用quartz来完成，在spirngboot 2以后可以直接通过starter的方式来引入。pom依赖如下： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt; quartz的主要组件 Jobdetail包含具体的任务信息 Trigger任务的触发器 Schedule具体的调度机制 SimpleScheduleBuilder简单任务调度 CronScheduleBuilder基于Crontab规则的任务调度 定义Jobdetail123JobDetail jobDetail = JobBuilder.newJob().withIdentity(new JobKey(jobName, JOB_DEFAULT_GROUP_NAME)) .ofType((Class&lt;Job&gt;) Class.forName(jobClass)) .build(); 定义调度规则简单任务调度，其中interval是指作业执行的时间间隔。下面的代码是以时间间隔为interval（单位：秒）的重复执行的调度规则。 1SimpleScheduleBuilder.repeatSecondlyForever(interval) crontab任务调度，其中cronExp是crontab表达式。 1CronScheduleBuilder.cronSchedule(cronExp) 定义好调度规则后，就可以定义触发器了。 定义触发器12345Trigger trigger = TriggerBuilder.newTrigger() .forJob(jobDetail) .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(interval)) .withIdentity(new TriggerKey(jobName, TRIGGER_DEFAULT_GROUP_NAME)) .build(); 添加作业到调度器12@Resourceprivate Scheduler scheduler; 12scheduler.scheduleJob(jobDetail, trigger);scheduler.start(); 为了方便作业的修改，定义一个作业的管理类，此类被定义为单例类，实现了对作业的添加，修改调度规则，作业的删除等。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190import com.aden.bern.leak.detection.job.AbstractJob;import lombok.extern.slf4j.Slf4j;import org.quartz.*;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.util.Map;/** * @author wangyong * @description */@Component@Scope(\"singleton\")@Slf4jpublic class QuartzManager implements ApplicationContextAware &#123; /** * 默认的作业组名称 */ private static final String JOB_DEFAULT_GROUP_NAME = \"JOB_GROUP\"; /** * 默认的触发器组名称 */ private static final String TRIGGER_DEFAULT_GROUP_NAME = \"JOB_GROUP\"; private ApplicationContext applicationContext; @Resource private Scheduler scheduler; @Resource private AutowiringSpringBeanJobFactory autowiringSpringBeanJobFactory; /** * 初始化 */ public void init() &#123; //启动所有任务 try &#123; scheduler.setJobFactory(autowiringSpringBeanJobFactory); //启动所有任务,这里获取AbstractTask的所有子类,继承的关系，取得所有子任务 Map&lt;String, AbstractJob&gt; tasks = applicationContext.getBeansOfType(AbstractJob.class); tasks.forEach((k, v) -&gt; &#123; Integer interval = v.getInterval();// String cronExp = v.getCronExpression(); if (interval != null) &#123; addJob(k, v.getClass().getName(), interval); &#125;// if (cronExp != null) &#123;// addJob(k, v.getClass().getName(), cronExp);// &#125; &#125;); log.info(\"Total jobs: &#123;&#125;，start jobs finished.\", tasks.size()); &#125; catch (SchedulerException e) &#123; log.error(e.getMessage(), e); throw new RuntimeException(\"init Scheduler failed\"); &#125; &#125; /** * 添加间隔性调度作业 * * @param jobName * @param jobClass * @param interval * @return */ public boolean addJob(String jobName, String jobClass, Integer interval) &#123; boolean result = false; try &#123; JobDetail jobDetail = JobBuilder.newJob().withIdentity(new JobKey(jobName, JOB_DEFAULT_GROUP_NAME)) .ofType((Class&lt;Job&gt;) Class.forName(jobClass)) .build(); Trigger trigger = TriggerBuilder.newTrigger() .forJob(jobDetail) .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(interval)) .withIdentity(new TriggerKey(jobName, TRIGGER_DEFAULT_GROUP_NAME)) .build(); scheduler.scheduleJob(jobDetail, trigger); scheduler.start(); result = true; &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); log.error(\"QuartzManager add job failed\"); &#125; return result; &#125; /** * 添加cron调度作业 * * @param jobName * @param jobClass * @param cronExp * @return */ public boolean addJob(String jobName, String jobClass, String cronExp) &#123; boolean result = false; if (!CronExpression.isValidExpression(cronExp)) &#123; log.error(\"Illegal cron expression format(&#123;&#125;)\", cronExp); return result; &#125; try &#123; JobDetail jobDetail = JobBuilder.newJob().withIdentity(new JobKey(jobName, JOB_DEFAULT_GROUP_NAME)) .ofType((Class&lt;Job&gt;) Class.forName(jobClass)) .build(); Trigger trigger = TriggerBuilder.newTrigger() .forJob(jobDetail) .withSchedule(CronScheduleBuilder.cronSchedule(cronExp)) .withIdentity(new TriggerKey(jobName, TRIGGER_DEFAULT_GROUP_NAME)) .build(); scheduler.scheduleJob(jobDetail, trigger); scheduler.start(); result = true; &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); log.error(\"QuartzManager add job failed\"); &#125; return result; &#125; /** * 更新作业 * * @param jobName * @param cronExp * @return */ public boolean updateJob(String jobName, String cronExp) &#123; boolean result = false; if (!CronExpression.isValidExpression(cronExp)) &#123; log.error(\"Illegal cron expression format(&#123;&#125;)\", cronExp); return result; &#125; JobKey jobKey = new JobKey(jobName, JOB_DEFAULT_GROUP_NAME); TriggerKey triggerKey = new TriggerKey(jobName, TRIGGER_DEFAULT_GROUP_NAME); try &#123; if (scheduler.checkExists(jobKey) &amp;&amp; scheduler.checkExists(triggerKey)) &#123; JobDetail jobDetail = scheduler.getJobDetail(jobKey); Trigger newTrigger = TriggerBuilder.newTrigger() .forJob(jobDetail) .withSchedule(CronScheduleBuilder.cronSchedule(cronExp)) .withIdentity(new TriggerKey(jobName, TRIGGER_DEFAULT_GROUP_NAME)) .build(); scheduler.rescheduleJob(triggerKey, newTrigger); result = true; &#125; else &#123; log.error(\"update job name:&#123;&#125;,group name:&#123;&#125; or trigger name:&#123;&#125;,group name:&#123;&#125; not exists..\", jobKey.getName(), jobKey.getGroup(), triggerKey.getName(), triggerKey.getGroup()); &#125; &#125; catch (SchedulerException e) &#123; log.error(e.getMessage(), e); log.error(\"update job name:&#123;&#125;,group name:&#123;&#125; failed!\", jobKey.getName(), jobKey.getGroup()); &#125; return result; &#125; /** * 删除作业 * * @param jobName * @return */ public boolean deleteJob(String jobName) &#123; boolean result = false; JobKey jobKey = new JobKey(jobName, JOB_DEFAULT_GROUP_NAME); try &#123; if (scheduler.checkExists(jobKey)) &#123; result = scheduler.deleteJob(jobKey); &#125; else &#123; log.error(\"delete job name:&#123;&#125;,group name:&#123;&#125; not exists.\", jobKey.getName(), jobKey.getGroup()); &#125; &#125; catch (SchedulerException e) &#123; log.error(e.getMessage(), e); log.error(\"delete job name:&#123;&#125;,group name:&#123;&#125; failed!\", jobKey.getName(), jobKey.getGroup()); &#125; return result; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125; init()方法是调度器的初始化方法，作用是在springboot启动的时候去加载所有作业的实例（即继承了AbstractJob抽象类 的子类，在下文中会描述此抽象类），并启动调度器scheduler。 实现具体的作业逻辑为了实现springboot在启动的时候加载所有的调度作业，首先定义一个抽象父类： 123456789101112131415161718192021222324import org.springframework.scheduling.quartz.QuartzJobBean;/** * @author wangyong * @description 所有具体的任务都需要继承此类 */public abstract class AbstractJob extends QuartzJobBean &#123; /** * crontab表达式 */ protected String cronExpression; /** * 任务时间间隔，单位：秒 */ protected Integer interval; public String getCronExpression() &#123; return cronExpression; &#125; public Integer getInterval() &#123; return interval; &#125;&#125; 所有的作业实例都需要继承这个父类，springboot在启动时候会加载所有此抽象类实现的作业实例。下面代码是一个简单的示例作业： 12345678910111213141516171819202122import lombok.extern.slf4j.Slf4j;import org.quartz.DisallowConcurrentExecution;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.springframework.stereotype.Component;/** * @author wangyong * @description 示例作业 */@Slf4j@Component@DisallowConcurrentExecutionpublic class SampleJob extends AbstractJob &#123; @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123; /* 在这个方法中完成需要的业务逻辑 */ System.out.println(\"作业调度！！！\"); &#125;&#125; 注意：作业的默认调度规则是每间隔规定的时间会启动一个线程去执行整个作业，但是如果不希望作业叠加执行，需要在具体的作业实例上添加@DisallowConcurrentExecution注解，这样就有当前次作业执行结束后才会开始下一次的执行。 与springboot整合这一部分使用spring中的事件监听器来初始化加载，实现了spring中的ApplicationListener接口中的onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent)方法。具体代码如下： 12345678910111213141516171819202122232425262728import lombok.extern.slf4j.Slf4j;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextRefreshedEvent;import org.springframework.stereotype.Component;import javax.annotation.Resource;/** * @author wangyong * @description */@Component@Slf4jpublic class ApplicationStartQuartzJobListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; @Resource private QuartzManager quartzManager; @Override public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) &#123; try &#123; quartzManager.init(); log.info(\"调度任务启动成功！\"); &#125; catch (Exception e) &#123; log.error(\"调度任务启动失败，&#123;&#125;\", e.getMessage()); &#125; &#125;&#125; 定义作业工厂，来获取Spring上下文然后在创建Job时让Job自动注入到Spring容器中： 1234567891011121314151617181920212223242526272829import org.quartz.spi.TriggerFiredBundle;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.AutowireCapableBeanFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.scheduling.quartz.SpringBeanJobFactory;import org.springframework.stereotype.Component;/** * @author wangyong * @description */@Componentpublic class AutowiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware &#123; private transient AutowireCapableBeanFactory beanFactory; @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123; final Object jobInstance = super.createJobInstance(bundle); beanFactory.autowireBean(jobInstance); return jobInstance; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.beanFactory = applicationContext.getAutowireCapableBeanFactory(); &#125;&#125; 在后续的业务迭代中，有新的作业需要只需要继承AbstractJob类，在executeInternal()方法中实现相应的作业逻辑就可以了。","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"the-valley.github.io/tags/springboot/"},{"name":"quartz","slug":"quartz","permalink":"the-valley.github.io/tags/quartz/"}]},{"title":"用java反射实现自定义规则对象属性拷贝","slug":"用java反射实现自定义规则对象属性拷贝","date":"2019-05-04T12:57:15.000Z","updated":"2019-05-05T03:18:04.903Z","comments":true,"path":"2019/05/04/用java反射实现自定义规则对象属性拷贝/","link":"","permalink":"the-valley.github.io/2019/05/04/用java反射实现自定义规则对象属性拷贝/","excerpt":"","text":"在工作中用到了protobuf，需要由protobuf类转成pojo，由于字段比较多，两个对象之间属性名不完全相同但是又存在一些映射规则，自己写了一个根据反射完成两个对象之间对应属性的赋值。直接上父抽象类代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import com.wy.exception.ConvertException;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;import java.beans.PropertyDescriptor;import java.lang.reflect.*;import java.util.Objects;/** * @author wangyong * @description pb对象与普通对象的转换 * @date 2019-04-10 */@Slf4jpublic abstract class AbstractConverter&lt;T, S&gt; &#123; private Class&lt;T&gt; targetClass; /** * 父类的构造函数，实例化一个目标类对象 */ public AbstractConverter() &#123; Type genericSuperClass = this.getClass().getGenericSuperclass(); //noinspection unchecked targetClass = ((Class&lt;T&gt;) ((ParameterizedType) genericSuperClass).getActualTypeArguments()[0]); &#125; /** * 执行转换 * * @param sourceObject 源对象 * @return */ public T convert(S sourceObject) &#123; T targetObject = newTargetClassInstance(); if (Objects.isNull(targetObject)) &#123; return null; &#125; PropertyDescriptor[] propertyDescriptors = BeanUtils.getPropertyDescriptors(targetObject.getClass()); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123; copyValue(sourceObject, targetObject, propertyDescriptor); &#125; return targetObject; &#125; /** * 属性赋值 * * @param sourceObject 源对象 * @param targetObject 目标对象 * @param targetPropertyDescriptor 目标对象属性描述 */ protected void copyValue(S sourceObject, T targetObject, PropertyDescriptor targetPropertyDescriptor) &#123; String targetPropertyName = targetPropertyDescriptor.getName(); //获取源类的与目标类当前属性对应的名称 String sourcePropertyName = mappingProperty(targetPropertyName); PropertyDescriptor sourcePropertyDescriptor = BeanUtils .getPropertyDescriptor(sourceObject.getClass(), sourcePropertyName); if (Objects.isNull(sourcePropertyDescriptor)) &#123; log.debug(\"source class &#123;&#125; has no property &#123;&#125;.\", sourceObject.getClass(), sourcePropertyName); return; &#125; beforSetProperty(sourcePropertyDescriptor, sourceObject); setProperty(sourceObject, targetObject, targetPropertyDescriptor, sourcePropertyDescriptor); &#125; /** * 对目标对象属性赋值 * * @param sourceObject 源对象 * @param targetObject 目标对象 * @param targetPropertyDescriptor 目标对象属性描述 * @param sourcePropertyDescriptor 源对象属性描述 */ protected void setProperty(S sourceObject, T targetObject, PropertyDescriptor targetPropertyDescriptor, PropertyDescriptor sourcePropertyDescriptor) &#123; //读取源对象属性 //得到源对象中当前属性的get方法 Method sourceReadMethod = sourcePropertyDescriptor.getReadMethod(); //得到目标对象中的对应属性的set方法 Method targetWriteMethod = targetPropertyDescriptor.getWriteMethod(); if (Objects.isNull(targetWriteMethod)) &#123; log.debug(\"can not get write method of &#123;&#125; in class &#123;&#125;\", targetPropertyDescriptor.getName(), targetObject.getClass()); return; &#125; try &#123; if (Objects.isNull(sourceReadMethod.invoke(sourceObject))) &#123; return; &#125; setAccess(targetWriteMethod).invoke(targetObject, sourceReadMethod.invoke(sourceObject)); &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; log.error(\"target class\" + targetObject.getClass().getName() + \" source class \" + sourceObject.getClass().getName() + \" target property \" + targetPropertyDescriptor.getName() + \" source property \" + sourcePropertyDescriptor.getName() + \" 赋值失败！\", e); &#125; &#125; /** * 如果方法的访问权限不为public，则修改为可以访问 * * @param method * @return */ private Method setAccess(Method method) &#123; if (!Modifier.isPublic(method.getModifiers())) &#123; method.setAccessible(true); &#125; return method; &#125; /** * 当构造函数的访问权限为私有时设置为可以访问 * * @param constructor * @return */ private Constructor setAccess(Constructor constructor) &#123; if (!Modifier.isPublic(constructor.getModifiers())) &#123; constructor.setAccessible(true); &#125; return constructor; &#125; /** * 对目标对象赋值前做的预处理 * * @param sourcePropertyDescriptor * @param sourceObject */ private void beforSetProperty(PropertyDescriptor sourcePropertyDescriptor, S sourceObject) &#123; &#125; /** * 具体字段名字的对应规则，默认不转换，子类可重写来实现新的对应规则 * * @param targetPropertyName 目标类的属性名称 * @return */ public String mappingProperty(String targetPropertyName) &#123; return targetPropertyName; &#125; /** * 实例化一个目标类属性 * * @return */ protected T newTargetClassInstance() &#123; try &#123; return targetClass.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; log.error(\"new instance of \" + targetClass.getName() + \" exception; \", e); return null; &#125; &#125;&#125; 泛型T为目标类型（比如pojo）S为源类型（比如PB类）。 实现自定义的字段映射规则子类通过重写此抽象类的mappingProperty(String targetPropertyName)方法来实现相应的属性映射规则。比如，当目标类的属性命名规则是源类的属性首字母小写时： 12345678910/** * 重写父类的字段映射规则，首字母小写 * * @param targetPropertyName 目标类的属性名称 * @return */ @Override public String mappingProperty(String targetPropertyName) &#123; return targetPropertyName.substring(0, 1).toLowerCase() + targetPropertyName.substring(1); &#125; 获取pb类的实例在使用protobuf类作为目标类时，需要使用pb类的builer来获取目标类的一个实例。因此在子类中需要重写父类的newTargetClassInstance()方法： 123456789/** * 当目标类为pb类时，重写父类的创建目标类实例的方法 * * @return */ @Override protected TargetClass.Builder newTargetClassInstance() &#123; return TargetClass.newBuilder(); &#125; 考虑到java反射的性能问题，在对程序性能要求比较高的场景中并不适合。","categories":[],"tags":[{"name":"java反射","slug":"java反射","permalink":"the-valley.github.io/tags/java反射/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-18T09:07:33.951Z","updated":"2019-03-18T09:07:33.951Z","comments":true,"path":"2019/03/18/hello-world/","link":"","permalink":"the-valley.github.io/2019/03/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}